import { createRequire } from "node:module";
import path from "node:path";
import { fileURLToPath } from "node:url";

import type { SandboxMode } from "./threadOptions";

export type NativeRunRequest = {
  prompt: string;
  threadId?: string;
  images?: string[];
  model?: string;
  sandboxMode?: SandboxMode;
  workingDirectory?: string;
  skipGitRepoCheck?: boolean;
  outputSchema?: unknown;
  baseUrl?: string;
  apiKey?: string;
  linuxSandboxPath?: string;
  fullAuto?: boolean;
  reviewMode?: boolean;
  reviewHint?: string;
};

export type NativeBinding = {
  runThread(request: NativeRunRequest): Promise<string[]>;
  runThreadStream(
    request: NativeRunRequest,
    onEvent: (err: unknown, eventJson?: string) => void,
  ): Promise<void>;
  clearRegisteredTools(): void;
  registerTool(info: NativeToolInfo, handler: (call: NativeToolInvocation) => Promise<NativeToolResult> | NativeToolResult): void;
};

export type NativeToolInfo = {
  name: string;
  description?: string;
  parameters?: unknown;
  strict?: boolean;
  supportsParallel?: boolean;
};

export type NativeToolInvocation = {
  toolName: string;
  callId: string;
  arguments?: string;
  input?: string;
};

export type NativeToolResult = {
  output?: string;
  success?: boolean;
  error?: string;
};

let cachedBinding: NativeBinding | null | undefined;

function getImportMetaUrl(): string | undefined {
  try {
    return Function(
      "return typeof import.meta !== 'undefined' && import.meta.url ? import.meta.url : undefined;",
    )() as string | undefined;
  } catch {
    return undefined;
  }
}

function resolveBindingEntryPath(): string {
  if (typeof __dirname === "string") {
    return path.resolve(__dirname, "..", "index.js");
  }

  const importMetaUrl = getImportMetaUrl();
  if (importMetaUrl) {
    try {
      const filePath = fileURLToPath(importMetaUrl);
      return path.resolve(path.dirname(filePath), "..", "index.js");
    } catch {
      // fall through to process.cwd()
    }
  }

  return path.resolve(process.cwd(), "index.js");
}

function resolveRequire() {
  const globalRequire = (globalThis as typeof globalThis & { require?: NodeJS.Require }).require;
  if (typeof globalRequire === "function") {
    return globalRequire;
  }

  if (typeof __filename === "string") {
    try {
      return createRequire(__filename);
    } catch {
      // fall through to other strategies
    }
  }

  const importMetaUrl = getImportMetaUrl();
  if (importMetaUrl) {
    try {
      return createRequire(importMetaUrl);
    } catch {
      // fall through to fallback strategy
    }
  }

  const fallbackBase = typeof __dirname === "string" ? __dirname : process.cwd();
  const fallbackPath = path.join(fallbackBase, "noop.js");
  return createRequire(fallbackPath);
}

export function getNativeBinding(): NativeBinding | null {
  if (cachedBinding !== undefined) {
    return cachedBinding;
  }

  const requireFn = resolveRequire();
  const bindingEntryPath = resolveBindingEntryPath();

  // For sdk/native: load the NAPI binding from the package root
  // The index.js is auto-generated by napi-rs and loads the .node file
  try {
    const binding: NativeBinding = requireFn(bindingEntryPath);
    cachedBinding = binding;
    return cachedBinding;
  } catch (error) {
    console.warn("Failed to load native NAPI binding:", error);
    cachedBinding = null;
    return cachedBinding;
  }
}
